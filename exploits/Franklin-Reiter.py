#! /usr/bin/sage -python

import os,sys,inspect
current_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

from RSA import *
from sage.all import *

# Calculates greatest common divisor and returns monic polynomial
def gcd(a, b):
    while b != 0:
        (a, b) = (b, a % b)
    return a.monic()





# Let m_1 != m_2
# m_1 = f(m_2) mod N , for  f = a * x + b in Z_n[x] with b != 0

m_2 = 1337
e = 3
a = 1
b = 2
# y = ax + b

# c_1 = (m_1)^e mod N

# g_1(x) = f(x)^e - c_1 , of course in z_n[x]. We know that m_2 must be a root of g_1.
# g_1(m_2) = f(m_2)^e - c_1 = c_1 - c_1 = 0

# g_2(x)_ = x^e - c_2. It is clear that m_2 is also a root of g_2.
# This means that (x - m_2) divides both g_1 and g_2
# So if gcd(g_1, g_2) is linear, we can find m_2.
# It turns out that for e = 3, the gcd is always linear, but for e > 3 it is not always the case.
# If it is not linear, then the attack will fail...


n_bits = 1024
num_users = 2
e_list = [3, 3]

user_list = gen_users_sameMod(n_bits, num_users, e_list)


N = user_list[0].N


#f(x) = a * x + b

# Create polynomial ring Z mod N
# R.<x> = Zmod(N)[]



R = Zmod(N)['x']; (x,) = R._first_ngens(1)

f = a * x + b


# use int(f(m_2)) to prevent segmentation fault. Sage and Python conversion
c1 = encrypt(int(f(m_2)), 3, N)

c2 = encrypt(m_2, 3, N)





g_1 = f(x)**e - c1
g_2 = x**e - c2

#print(gcd(g_1, g_2))

print(-gcd(g_1, g_2).coefficients()[0])
print("Hello World")



# If you have x + 5 then you get coefficients [5, 1] in Sage, so we need index 0 to get -m
# Of course, remember the calculations are in Polynomial ring Z Mod N
#print(-gcd(g_1, g_2).coefficients()[0])

#print(gcd(g_1, g_2).degree())







