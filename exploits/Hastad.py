#! /usr/bin/sage -python

import os
import sys
import inspect

current_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

from sage.all import *
from RSA import *

def Hastad_BCA(a_list, b_list, c_list, n_list, e_list):

    # T_i = 1 (mod n_i)
    # T_i = 0 (mod n_j!=i)

    # Let Z be T_i = Z
    list_T_i = []

    for i in range(len(n_list)):
        # First set all Z's to 0
        list_of_Z = [0] * len(n_list)

        # Set Z_i to 1, so T_i = 1 for mod n_i and T_i = 0 for all others
        list_of_Z[i] = 1

        # Use Chinese Remainder Theorem and solve T_i and save it
        T_i = CRT(n_list, list_of_Z)
        list_T_i.append(T_i)

    # N is product of all n_i in n_list
    N = 1
    for n_i in n_list:
        N *= n_i

    # Create polynomial ring Z Mod N
    P = PolynomialRing(Zmod(N), names=('x',))
    (x,) = P._first_ngens(1)

    # Find out max degree
    max_degree = 1
    for current_e in e_list:
        if current_e > max_degree:
            max_degree = current_e

    # We have the public linear padding function: padded_message = a_i * m_i + b_i
    # Create polynomial T_i * g_i = T_i * ((a_i * x + b)^e_i - c_i) and then sum all results to get g(x)
    g = 0
    for index in range(len(e_list)):

        # If degree of exponent is not max_degree, multiply with x^j, so that the degree becomes max_degree
        if e_list[index] < max_degree:
            T_i_g_i = list_T_i[index] * (((a_list[index] * x + b_list[index])**e_list[index] - c_list[index]) * x**(max_degree-e_list[index]))
        else:
            T_i_g_i = list_T_i[index] * ((a_list[index] * x + b_list[index])**e_list[index] - c_list[index])
        g += T_i_g_i

    print()
    print("Polynomial g = " + str(g))

    # Make polynomial g monic
    g = g.monic()
    print()
    print("Monic polynomial g = " + str(g))
    print()

    start_time_find_root = time.time()

    # Epsilon might need to be changed, depending on the message and the chosen exponent to increase search space
    # We need 1/d > epsilon where d is the degree of the polynomial and epsilon by default = 1/8
    # For example g.small_roots(epsilon=1/12)

    # Use Coppersmith's method to find the smallest root of polynomial g
    secret_message = g.small_roots()
    end_time_find_root = time.time()

    print("Time elapsed to find smallest root: " + str(end_time_find_root - start_time_find_root) + " seconds")
    return secret_message[0]
