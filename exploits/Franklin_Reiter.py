#! /usr/bin/sage -python

import os
import sys
import inspect
current_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

from sage.all import *

# Calculates greatest common divisor and returns monic polynomial
def gcd(a, b):
    while b != 0:
        (a, b) = (b, a % b)
    return a.monic()

# Franklin-Reiter Related Message Attack
def Franklin_Reiter_Attack(c_1, c_2, e, f, N):

    # Define the polynomial ring Z mod N, otherwise we cannot assign g_i
    R = Zmod(N)['x']; (x,) = R._first_ngens(1)

    # g_1(x) = f(x)^e - c_1 , of course in z_n[x]. We know that m_2 must be a root of g_1.
    # g_1(m_2) = f(m_2)^e - c_1 = c_1 - c_1 = 0
    # g_2(x)_ = x^e - c_2. It is clear that m_2 is also a root of g_2.
    g_1 = f(x)**e - c_1
    g_2 = x**e - c_2

    # This means that (x - m_2) divides both g_1 and g_2
    # So if gcd(g_1, g_2) is linear, we can find m_2.
    # It turns out that for e = 3, the gcd is always linear, but for e > 3 it is not always the case.
    # If it is not linear, then the attack will fail...

    # If you have x - m_2 as greatest common divisor,
    # then you get coefficients [-m_2, 1] in Sage, so we need index 0 to get -m_2
    # Of course, remember the calculations are in Polynomial ring Z Mod N
    result = -gcd(g_1, g_2).coefficients()[0]
    gcd_degree = gcd(g_1, g_2).degree()
    if gcd_degree > 1:
        print("Attack failed, the gcd was not linear. Degree was: " + str(gcd_degree))
        return -1
    else:
        return result % N
